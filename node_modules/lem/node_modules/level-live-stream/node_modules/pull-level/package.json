{
  "name": "pull-level",
  "description": "pull-stream interface to levelup",
  "version": "1.1.12",
  "homepage": "https://github.com/dominictarr/pull-level",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/pull-level.git"
  },
  "dependencies": {
    "pull-stream": ">=2.20 <3",
    "pull-pushable": "1",
    "pull-window": ">=2.1.2 <3",
    "pull-cat": ">=1.1 <2",
    "stream-to-pull-stream": "1.3",
    "level-post": "~1.0.3"
  },
  "devDependencies": {
    "monotonic-timestamp": "0.0.8",
    "level-sublevel": "~4.1.0",
    "rimraf": "~2.1.4",
    "level": "~0.10.0",
    "tape": "~2.13.3"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "license": "MIT",
  "readme": "# pull-level\n\n[pull-stream](https://github.com/dominictarr/pull-stream) interface to\n[levelup](https://github.com/rvagg/node-levelup)\n\n## Example - reading\n\nread items in database.\n\n``` js\nvar pl = require('pull-level')\nvar pull = require('pull-stream')\n\nvar db = require('levelup')('/tmp/pull-level-example')\n\npull(pl.read(db), pull.collect(console.log))\n```\n\nread items in database, plus realtime changes\n\n``` js\npull(\n  pl.read(db, {tail: true}),\n  //log data as it comes,\n  //because tail will keep the connection open\n  //so we'll never see the end otherwise.\n  pull.through(console.log),\n  //note, pull-streams will not drain unless something is\n  //pulling the data through, so we have to add drain\n  //even though the data we want is coming from pull.through()\n  pull.drain()\n)\n```\n\nIf you just want the realtime inserts,\nuse `live`\n\n``` js\npull(\n  pl.live(db, {tail: true}),\n  pull.through(console.log),\n  pull.drain()\n)\n```\n\n## Example - writing\n\nTo write, pipe batch changes into `write`\n\n``` js\npull(\n  pull.values([\n    {key: 0, value: 'zero', type: 'put'},\n    {key: 1, value: 'one',  type: 'put'},\n    {key: 2, value: 'two',  type: 'put'},\n  ]),\n  pl.write(db)\n)\n```\n\nIf you are lazy/busy, you can leave off `type`.\nIn that case, if `value` is non-null, the change\nis considered a `put` else, a `del`.\n\n``` js\npull(\n  pull.values([\n    {key: 0, value: 'zero'},\n    {key: 1, value: 'one'},\n    {key: 2, value: 'two'},\n  ]), \n  pl.write(db)\n)\n```\n\n\n## Example - indexes!\n\nWith pull-level it's easy to create indexes.\njust save a pointer to the key.\n\nlike this:\n``` js\npull(\n  pull.values([\n    {key: key, value: VALUE, type: 'put'},\n    {key: '~INDEX~' + VALUE.prop, value: key,  type: 'put'},\n  ]),\n  pl.write(db)\n)\n```\n\nthen, when you want to do a `read`, use `asyncMap`\n\n``` js\npull(\n  pl.read(db, {min: '~INDEX~', max: '~INDEX~~'})\n  pull.asyncMap(function (e, cb) {\n    db.get(e.value, function (value) {\n      cb(null, {key: e.value, value: value})\n    })\n  }),\n  pull.collect(console.log)\n)\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dominictarr/pull-level/issues"
  },
  "_id": "pull-level@1.1.12",
  "_from": "pull-level@~1.1.10"
}
