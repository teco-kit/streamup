{
  "name": "lem",
  "version": "0.4.8",
  "description": "telemetry database for time-series data using LevelDB and node.js",
  "main": "src/index.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/binocarlos/lem.git"
  },
  "keywords": [
    "telemetry",
    "database",
    "time",
    "series",
    "leveldb"
  ],
  "devDependencies": {
    "mocha": "~1.14.0",
    "should": "~2.1.0",
    "wrench": "~1.5.8",
    "async": "~0.2.10",
    "hyperquest": "~0.2.0",
    "concat-stream": "~1.4.4"
  },
  "author": {
    "name": "Kai Davenport"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/binocarlos/lem/issues"
  },
  "homepage": "https://github.com/binocarlos/lem",
  "dependencies": {
    "through": "~2.3.4",
    "level": "~0.18.0",
    "level-live-stream": "~1.4.9"
  },
  "readme": "lem\n===\n\n![lem logo](https://github.com/binocarlos/lem/raw/master/graphics/logosmall.png \"Lem Logo\")\n\n![Build status](https://api.travis-ci.org/binocarlos/lem.png)\n\ndatabase for time-series data using LevelDB and node.js\n\n## installation\n\n```\n$ npm install lem\n```\n\n## usage\n\n```js\nvar lem = require('lem');\nvar level = require('level');\n\n// create a new leveldb - this can also be a sub-level\nvar leveldb = level('/tmp/lemtest');\n\n// create a new lem store using the leveldb\nvar lemdb = lem(db);\n\n// when nodes are indexed\nlemdb.on('index', function(key, meta){\n\n})\n\n// a live stream from the database\nlemdb.on('data', function(data){\n\n})\n\n// nodes are represented by keys\nvar key = 'myhouse.kitchen.fridge.temperature';\n\n// index a node with some meta data\nlemdb.index(key, 'My Fridge Temp');\n\n// create a recorder which will write data to the node\nvar temp = lemdb.recorder(key);\n\n// write a value every second\nsetInterval(function(){\n\ttemp(Math.random()*100);\n}, 1000)\n\n```\n\n## timestamps\n\nWhen values are written to recorders - they are timestamped.  Sometimes - more acurate timestamping (like a GPS source) is used - you can provide the timestamp to the recorder:\n\n```js\nvar temp = lemdb.recorder('timestamp.test');\nsetInterval(function(){\n\t// get a custom timestamp from somewhere - the current time is the default\n\tvar timestamp = new Date().getTime();\n\ttemp(Math.random()*100, timestamp);\n}, 1000)\n```\n\n## index\n\nYou can read the index from any point in the tree - it returns a ReadStream of the keys that have been indexed:\n\n```js\n...\nvar through = require('through');\n\n// index a key into the tree\nlemdb.index('cars.red5.speed', 'The speed of the car', function(){\n\tvar keysfound = {};\n\n\t// keys returns a readstream of objects each with a 'key' and 'data' property\n\tlemdb.keys('cars.red5').pipe(through(function(data){\n\t\tkeysfound[data.key] = data.value;\n\t}, function(){\n\t\tconsole.log('Meta: ' + keysfound.speed);\n\t})\n})\n```\n\nThis will log:\n\n```\nMeta: The speed of the car\n```\n\n## valuestream\n\nCreate a ReadStream of telemetry values for a node - you can specify start and end keys to view windows in time:\n\n```js\n\n// create a range - this can be a 'session' to make meaningful groups within lem\nvar sessionstart = new Date('04/05/2013 12:34:43');\nvar sessionend = new Date('04/05/2013 12:48:10');\nvar counter = 0;\nvar total = 0;\n\nvar secs = (sessionend.getTime() - sessionstart.getTime()) / 1000;\n\nlemdb.valuestream('cars.red5.speed', {          \n\tstart:sessionstart.getTime(),\n\tend:sessionend.getTime()\n}).pipe(through(function(data){\n\n\t// this is the timestamp of the value\n\tvar key = data.key;\n\n\t// this is the actual value\n\tvar value = data.value;\n\n\t// map-reduce beginnings\n\ttotal += value;\n\tcounter++;\n}, function(){\n\n\tvar avg = 0;\n\n\tif(counter>0){\n\t\tavg = total / counter;\n\t}\n\n\tconsole.log('average speed of: ' + avg);\n\tconsole.log('data points: ' + total);\n\tconsole.log('time period: ' + secs + ' secs');\n\t\n}))\n```\n\n## api\n\n#### `var lemdb = lem(leveldb);`\n\nCreate a new lem database from the provided [leveldb](https://github.com/rvagg/node-levelup).  This can be a [level-sublevel](https://github.com/dominictarr/level-sublevel) so you can partition lem into an existing database.\n\n```js\nvar lem = require('lem');\nvar level = require('level');\n\nvar leveldb = level('/tmp/mylem');\nvar lemdb = lem(leveldb);\n```\n\n#### `lemdb.index(path, meta, [done])`\n\nWrite a node and some meta data to the index. \n\nThe index is used to build a tree of key-values that exist without having to traverse the time-stamped keys.\n\nThe stream returned can be used to build any kind of data structure you want (list, tree, etc).\n\nThe meta data for each node is saved as a string - you can use your own encoding (e.g. JSON).\n\nCreate some indexes:\n\n```js\nlemdb.index('myhouse.kitchen.fridge.temperature', '{\"title\":\"Fridge Temp\",\"owner\":344}');\nlemdb.index('myhouse.kitchen.thermostat.temperature', '{\"title\":\"Stat Temp\",\"owner\":344}');\n```\n\n#### `lemdb.keys(path)`\n\nkeys returns a ReadStream of all keys in the index beneath the key you provide.\n\nFor example - convert the stream into a tree representing all nodes in the kitchen:\n\n```js\n...\nvar through = require('through');\nvar tree = {};\nlemdb.keys('myhouse.kitchen').pipe(through(function(data){\n\ttree[data.key] = data.value;\n}, function(){\n\tconsole.dir(tree);\n}))\n```\n\nThis outputs:\n\n```js\n{\n\t\"fridge.temperature\":'{\"title\":\"Fridge Temp\",\"owner\":344}',\n\t\"thermostat.temperature\":'{\"title\":\"Stat Temp\",\"owner\":344}'\n}\n```\n\n#### `lemdb.recorder(path)`\n\nA recorder is used to write time-series data to a node.\n\nYou create it with the path of the node:\n\n```js\nvar recorder = lemdb.recorder('myhouse.kitchen.fridge.temperature');\n```\n\n#### `recorder(value, [timestamp], [done])`\n\nThe recorder itself is a function that you run with a value and optional timestamp and callback.\n\nIf no timestamp is provided a default is created:\n\n```js\nvar timestamp = new Date().getTime();\n```\n\nThe callback is run once the value has been committed to disk:\n\n```js\n\n// a function to get an accurate time-stamp from somewhere\nfunction getProperTime(){\n\treturn ...;\n}\n\n// a function to return the current value of an external sensor\nfunction getSensorValue(){\n\treturn ...;\n}\nvar recorder = lemdb.recorder('myhouse.kitchen.fridge.temperature');\n\n// sample the value every second\nsetInterval(function(){\n\tvar value = getSensorValue();\n\tvar timestamp = getProperTime();\n\trecorder(value, timestamp, function(){\n\t\tconsole.log(timestamp + ':' + value);\n\t})\n}, 1000)\n\n```\n\n## events\n\n#### `lemdb.on('index', function(key, meta){})`\n\nthe 'index' event is emitted when a node is added to the index:\n\n```js\nlemdb.on('index', function(key, meta){\n\tconsole.log('the key is: ' + key);\n\n\t// the meta is a string\n\tvar obj = JSON.parse(meta);\n\tconsole.dir(obj);\n})\n```\n\n#### `lemdb.on('data', function(key, value){})`\n\t\nThis is a livestream from leveldb and so contains a full description of the operation:\n\n```js\nlemdb.on('index', function(data){\n\tconsole.dir(data);\t\n})\n```\n\nThis would log:\n\n```js\n{ type: 'put',\n  key: 'values~cars~red5~speed~1394886656496',\n  value: '85'\n}\n```\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "lem@0.4.8",
  "_from": "lem@"
}
